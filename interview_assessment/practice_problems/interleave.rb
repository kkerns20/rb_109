=begin
Create a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with nils.

Examples:

p interleave([1, 2, 3], ["c", "d", "e"]) == [1, "c", 2, "d", 3, "e"]
p interleave([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3, nil]
p interleave([1, 2, 3], [4, 5, 6], [7, 8, 9]) == [1, 4, 7, 2, 5, 8, 3, 6, 9]
p interleave([]) == nil

Problem
------------------------------------------


Inputs: 3 arrays
Outputs: 1 combined array

Rules/Requirements
- pad the shorter arrays with nil

Clarifying Questions
- 

Examples, Test Cases
------------------------------------------
[1, 2, 3], [4, 5, 6], [7, 8]) => [1, 4, 7, 2, 5, 8, 3, 6, nil]
1 push to output
4 push to output
7 push to output
2 push to output
5 push to output
8 push to output
3 push to output
6 push to output
don't have third ele or ind 2, so push nil to output

Data Structure, Algorithm
------------------------------------------
assign output array to an empty array
start a range from 0 to but not including max size
  append arr1 at index to output array
  append arr 2 at index to the output array
  append arr3 at index to output array
return output array

helper max_size(arr1, arr2, arr3)
create arr of the input arrays
iterate through with transformation
  call size on each array and return the max value

=end

def max_size(*arrays)
  arrays.map(&:size).max
end

def interleave(*arrays)
  output = []
  (0...max_size(*arrays)).each do |index|
    arrays.each { |arr| output << arr[index] }
  end
  output
end

def interleave(*args)
  # (0 ... args.map(&:size).max) || 0).flat_map{ |i| args.map{ |xs| xs[i] } }
end

p interleave([1, 2, 3], ["c", "d", "e"]) == [1, "c", 2, "d", 3, "e"]
p interleave([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3, nil]
p interleave([1, 2, 3], [4, 5, 6], [7, 8]) == [1, 4, 7, 2, 5, 8, 3, 6, nil]
p interleave([1, 2, 3], [4, 5], [6, 7, 8]) == [1, 4, 6, 2, 5, 7, 3, nil, 8]
p interleave([1, 2, 3], [4, 5], [6, 7, 8, 9]) == [1, 4, 6, 2, 5, 7, 3, nil, 8, nil, nil, 9]
p interleave([]) == []
